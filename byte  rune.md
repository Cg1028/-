go doc builtin.函数名：看描述函数的文档

//定义多行字符串

word:=`十年生死两茫茫

不思量

自难忘`

//字符串拼接 fmt.Sprintf

//字符串分割fmt.Split

//字符串包含strings.Contains(字符串名,"指定字符")

//字符串索引strings.Index(字符串名,"指定字符")





byte  rune

rune中len按字数来，string中汉字3byte字母1byte，

可以用len(string)-len(rune)的一半来测算字符串中汉字数目。

if循环：

if 表达式（必须返回一个布尔值）{

​        操作代码

} else{

​        操作代码

}

多个判断条件：

if 表达式{}

else if 表达式{}......    

！！！注意，if后可以直接跟一个表达式，其中变量作用域只在if中，即用即删，节省内存。



for循环：

for  初始语句1;判断语句2;结束语句4{

​        操作代码3

}

变种1：

for ;判断;结束{

​        操作

}

变种2：

for ;判断{

​        操作

}

变种3：

for{

​        操作

}

for range 循环



switch:

switch 表达式;变量{  

​          case 值值值值...   :

​                       操作代码

​          case 值:

​                       操作代码

​          case 值:

​                       操作代码

​          case 值: 

​                       操作代码

​          case 值:

​                       操作代码

​          default:

​                       操作代码

}

flag,根据其布尔值可以用if跳出多层逻辑操作。



goto 标识符

标识符:

​          操作代码





go语言中

A++为一个单独语句





逻辑运算符

if age>18 && age<60{

​          操作代码

}

if age<18 || age>60{

​          操作代码

}



位运算符，针对二进制数。

5的二进制101

2的二进制010

&：按位与

fmt.Println(5&2)

//101

   010

   000

结果为0   //



|:按位或

//101

   010

   111

结果为7     //



^:按位异或

//101

   010 

   111

结果为7     //



<<:将二进制位左移指定位数

5<<1

//101变成1010

结果为10      //即*2的1次方





数组array：

var 标识符 [ 长度 ] 数据类型{        元素       }

！！！在Go中长度是类型的一部分，长度不同的数组即使数据类型一样也不能比较。

初始化   false，0 ，""

标识符:=[...]数据类型{              }



标识符:=[5]数据类型{0:1,4:2}

索引初始化，否则补零，即[1,2,0,0,0]

初始化后为[1,0,0,0,2]







数组的遍历

索引遍历

数组名

for i:=0;i<len();i++{

​         Println(数组名[i])

}





for i,v:=range 数组名 {

​       Println(i,v)

}



多维数组

[[1,2] [3,4] [5,6]]

var a [3] [2]int



a=[3] [2]int{

   [2]int{变量}

   [2]int{3,4}

   [2]int{5,6}

}



多维数组遍历

for_,v1:=range a{

​        for_,v2:=range v1{

​      }

}





切片，属于引用类型



切片的声明：

var 标识符=make([]数据类型,长度,容量)

标识符 := []数据类型{元素 元素...}

!!切片只能与nil作比较，判断是否为空。

长度和容量：

len(标识符)        cap(标识符)



由数组得到切片：

标识符:=数组名[1:5]

（新得到的切片有四个元素，分别是数组的第2.3.4.5个元素）

还可以这样：

标识符:=数组名[:5]（从第一个元素开始）

标识符:=数组名[1:]（一直到最后一个元素）

标识符:=数组名[:]（获取所有元素组成切片）



切片的容量是指底层数组从切片的第一个元素到最后一个数组元素的数目。

切片再切割，格式相同。底层数组不变。



make函数：

标识符=make([]数据类型，5 ，10)

​                                       长度↑容量↑

s1=[0 0 0 0 0] len(s1)=5 cap(s1)=10

 

判断切片是不是空的要用len()而非==nil，因为容量长度均为零的切片可能有底层数组占用内存，彼时该切片!=nil。

切片的赋值：s1[1]=999

这步操作改变了底层数组的元素，之后的切片也会有相应改变。

切片的遍历：

for i:=0;i<len;i++{

​                操作代码

}

for i,v:=range 数组名{

​                操作代码

}



append为切片追加元素。必须用原来的切片变量接收返回值。

底层数组放不下时候，会换一个新的底层数组。

s1 = append(s1 ,  追加元素)



扩容策略：如果不超过两倍，给两倍；超过两倍但是长度不超过1024，给新申请的量；超过1024则1/4速度扩容，直到达到申请量；最后一次1/4扩容超过申请量，给申请量。   



append为切片追加切片。

s1 = append(s1 , s2 . . . )

（ . . . 为拆切片为元素，此后将元素追加到前一切片。）



copy 

copy( a1 , a2 )

将后者元素复制一份给前者。二者用不同内存，与赋值操作不同。

注意，用来接收copy元素的切片必须有足够的长度与容量。

var a1=make([ ]数据类型,5,10)

 

删除切片中的元素（思路：在该元素前面元素组成的切片后追加该元素后的元素组成的切片。） 

!!1.切片不保存值。

!!2.切片对应表示一个底层数组的子集。

!!3.底层数组占用一块连续内存。

所以，在对切片进行操作时，实际是对底层数组进行操作，使得切片对应的数组元素改变，以此改变切片表示内容。

x1:=[...]int{1,3,5,7,9}

s1:=x1[:]//这一步得到的切片s1其len与cap与x1相同。

s1=append(s1[:1],s1[2:]...)//在s1[:1]基础上追加s1[2:]

//此时，s1=[1,5,7,9]，成功删去元素'3'



Go语言里指针：

记住两个符号：'&':取地址||||'*':根据地址取值

切片存的是内存地址。地址一般两个字节。 

var 标识符1 = *数据类型//获得一个对应数据 类型空指针。

var 标识符2 = new(数据类型)//new函数申请一个内存地址

*标识符2 = 100

fmt.Println(*标识符2)=>100



new与make的区别：都申请内存，但是

new一般给基本数据类型申请内存（str\int...）返回的是指针。

make用来给slice、map、chan申请内存，返回的是三种类型本身。



map，提供一种映射关系。

例：str为key数据类型，int为变量数据类型。

var 标识符 map [str] int//要用make初始化。

标识符 = make(map[str]int，容量)//尽量避免动态扩容。

标识符["例子1"] = 666

标识符["例子2"] = 667

标识符["例子3"] = 668

fmt.Println("例子4")=>拿到对应类型的零值



检验键（key）是否存在：

value,ok:=标识符["例子4"]

if !ok{   操作代码

}else{   操作代码

}



map的遍历

for k,v:=range 标识符{

​         fmt.Println(k,v)

}

运用匿名变量可以只遍历key或者值。



删除：

delete(标识符,"例子3")



按照一定顺序遍历map：

首先制造或输入一个map，然后取得排序依据，放进一个切片中。

var TURNS(标识符)=make([]数据类型,长度(应该是0),容量)

//声明切片

for turn := range map {

​        TURNS = append(TURNS,turn)

}

//取得作为排序依据的变量并放进切片。

sort.根据数据类型(TURNS)

//给TURNS里的变量排序。

for _,turn:= range TURNS{

​          fmt.Println(turn,map[turn])

}

//遍历切片里排序后的turn（作为排序依据的变量），并输出其在map里对应的值。

shuzu:=[...]int{2,1,3,4}

var s1 = [3] [2]int{

{1,4}{2,5}{3,6}

}

qiepian:=[]int{1,2,3}

s2:=make([]int,2)



函数：

func 函数名 (参数，参数..)(返回值){

​               函数体

}

可变长参数

func f1(x string , y float , z ... int)    //z的类型是切片。



//判断字符串中汉字数量



Word1:="hello world 你好 世界"

var counter int        //声明计数作用的整型变量

for _,c:=range Word1{

​                 if  unicode.Is(unicode.Han,c){     //判断是否是汉字

​                           counter++

}

}

fmt.Println(counter)



//判断字符串里单词出现的次数

Word2:="how do you do"

letter:=strings.Split(Word2," ")

mapWord :=make(map[string]int,10) 

for _,v:=range letter{

if _,ok:=mapWord[v];!ok{

mapWoed[v]=1

}else{

mapWord[v]++

​           }

for k,v:=range mapWord{

​       fmt.Println(k,v)

}





高阶函数

func sayHello(name string){

fmt.Printf("Hello,%s",name)

}

func test(name string,f func (string)){

f(name)

}

func main(){

test("tom",sayHello)

}



匿名函数

r:=func(a int,b int)int{

}(1,2)   //把1，2作为参数调用自己并将返回值赋值给r。



匿名函数可以写进另一个函数实现嵌套，

闭包：

1）函数返回一个函数

2）闭包说明：函数与引用的函数外变量组成的整体。

3）闭包是类，函数是操作，函数外变量是字段。

4）反复调用时变量会累加，因为初始化语句在函数外。



strconv函数

a:=strconv.Atoi(b)   //将字符串转为int类型

















buildteam

遍历数组查看数组（团体）里有无成员（数字），无则添加



或者map key判断团体有无二人，无则添加，map的key就是小团体花名册。

？小团体数目=>map/数组的数目，不好确定。

动态创建新团体。？？？？

  quaryteam

查二人是否在key里，输出bool。

||作判断



map[int] []int











































