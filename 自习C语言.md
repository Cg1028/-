do语句：至少执行一次，后续看while。

do   {

code

}while(  条件  )



*用do while 循环限定条件。



!5=0

!0=1



德摩根定律

把条件取与、或互换再取非，条件不变。

x&&y==!(!x||!y)



多重循环，九九乘法表为例：

i为纵方向，j横方向，在i的1→9中嵌套一个j的1→9。



程序的组成元素和格式。

标识符长度一般8字符。

标识符区分大小写。

标识符要做到顾名思义。

注意格式和缩进。

插入问题：关键词间不能插入空格、预处理不换行、常量中间不能换行。

%5.2f：输出五位长度，保留两位小数



C中数组：

数组声明   ：   int  v  [ 5 ]  =  {1,2,3,4,5}

（声明的中括号是分隔符，拿取元素的时候中括号是运算符）

默认初始化0



for（条件）{

​        代码

}



对数组排列倒序：两两一组用第三方变量交换值。



对象式宏：严格的替换，把代码里的元素全部替换。

例子：#define  number  5  （把number换成5）



数据存储方式：原码→反码→补码

补码：char ch=10   :   00001010  首位0表示正。

但是不便于不同符号数计算。

反码：00001010（对于正数来说反码就是源码）

对于负数来说符号位不变，其余取反。

-10：10001010（原码）11110101（反码）

补码：对于正数来说三码一致。

对于负数来说，补码是反码加一。



补码符号位不动，其他位求反，最后整个数加一得到原码。

-10：10001010（原码）

11110101（反码）

11110110（补码）



”0“在计算机中存储方式：

1统一了零的编码0000 0000

2将符号位和其他位统一处理

3减法变为加法计算

4用两个补码表示的数相加如果有最高位（符号位）有进位，会被舍弃 



goto 可以用来goto自己，做死循环。



数组定义和使用：

数据类型  数组名 [元素个数]={}



数组在内存中存储方式和大小

 4个字节存一个数据。



数组名是一个指向数组首地址的地址常量。

数组在内存中占的大小：sizeof （数组名）等于数据类型*元素个数

数组元素大小：sizeof（数组名[n]）

数组元素个数：数组大小/元素大小，可以作为用来遍历数组时候的len。

数组名[常量或者常量表达式]，必须预先知道大小。

数组下标越界能执行，数据乱。

数组逆置：数组倒序输出，用数组下标和一个临时变量交换数据。



冒泡排序：每次比较次数为需要排序元素-1，

即元素个数-执行次数-1



二维数组定义和使用：

数据类型   数组名[2 行 ]  [3 列 ]  =    {

{1，2，3}

{4，5，6}

​           }

地图的坐标、游戏的贴图......

数组名[1] [2]=20(改变6为20)

遍历二维数组：for 循环 行   嵌套   for 循环   列



sizeof a (行数)

sizeof a[0]（列数）

a 

a[0]

&a[0] [0]//上面是地址常量，第三行才是变量。





动态规划，最大子矩阵：

最大子数组和：

例[5,4,-1,7,8]

从头开始，5没得操作，直接取5.

对4来说，dp=max（5，5+4），自然我们取9。

然后看-1，dp=max（-1，-1+9），自然我们取8。

7，dp=max（7，7+8），取15。

8，取23。





用i，j，k遍历矩阵，得到所有子矩阵，对每一个子矩阵进行列求和



const类型修饰符修饰形参可以防止调用函数时修改数据的操作。



哨兵查找法：在数组后添加一个待查找的值。

一般情况下我们需要while（1）{

​                       if （i==n）{return0；}

​                       if（条件）{代码块}

}

末尾添加的值确保第二个if在最后一定会保证程序查到值并退出循环（设定是这样），因此可以省掉第一个if的判断。



dp[i] [j] 最好i，j从1开始。



双指针：

1两个指针，方向相反。

譬如两数之和，两个指针分别在两端，因为数组已经升序排列，所以从两端开始，当两端之和大于目标值时右端指针左进一位，反之亦然。



2方向相同。

譬如两个有序数组的合并，合并后的新数组保持有序。

两个指针分别从头指向两个数组，比较其值，将较小值加到结果数组里，然后调整较小值的指针位置进一位。注意两个数组长度不同时候要最后处理下多余部分。



3快慢指针。

判断单链表是否存在“环”。快指针等于慢指针时候存在环。



4方向相同，但是起点不同。

返回单链表倒数第n个节点，前指针null时后指针到了目标节点。































